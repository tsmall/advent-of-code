(ns aoc.y2016.day15
  (:require [clojure.string :as str]
            [clojure.test :refer [deftest is]]))

;; -----------------------------------------------------------------------------
;; Input Parsing

(def line-re
  "Regex that matches a single line of the input."
  #"Disc #\d+ has (\d+) positions; at time=0, it is at position (\d+).")

(defn parse-line
  "Returns the size and position of a disc described by line."
  [line]
  (let [matches (first (re-seq line-re line))]
    (map #(Integer/parseInt %) (rest matches))))

(defn parse-input
  "Returns the state generated by parsing the input text."
  [text]
  (let [lines (str/split-lines text)
        discs (map parse-line lines)
        [sizes positions] (apply map conj [[] []] discs)]
    {:sizes sizes
     :positions positions}))

;; -----------------------------------------------------------------------------
;; Solution

(defn rotate-disc
  "Returns the rotated position of a disk at seconds."
  [size position seconds]
  (mod (+ position seconds) size))

(defn rotate-all
  "Returns the updated state with all discs rotated at time."
  [time {:keys [sizes positions] :as state}]
  (let [disc-times (iterate inc (inc time))
        new-positions (map rotate-disc sizes positions disc-times)]
    (assoc state
           :positions new-positions
           :time time)))

(defn falls-through?
  "Returns true if the ball would fall through all discs."
  [{:keys [positions]}]
  (every? zero? positions))

(defn find-winning-time
  "Returns the first time the ball would fall through all discs."
  [state]
  (some (fn [state] (if (falls-through? state) (:time state)))
        (map-indexed rotate-all (repeat state))))

(defn part1
  "Returns the answer to Part 1, given the input file."
  [input-file]
  (let [state (parse-input (slurp input-file))]
    (find-winning-time state)))

(defn part2
  "Returns the answer to Part 2, given the input file."
  [input-file]
  (let [state (-> (parse-input (slurp input-file))
                  (update :sizes conj 11)
                  (update :positions conj 0))]
    (find-winning-time state)))

(deftest expected-answers
  (is (= (part1 "../example.txt") 5))
  (is (= (part1 "../input.txt") 16824))
  (is (= (part2 "../input.txt") 3543984)))

(comment
  (time (part1 "../example.txt"))
  (time (part1 "../input.txt"))
  (time (part2 "../input.txt"))
  )
